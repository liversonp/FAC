#comando para rodar:
#spim -f nome.spim

.data
    cbn: .asciiz "\n"
    sla: .asciiz "sla"
    sla2: .asciiz "seisim"
.text
main:
    li $v0, 5       #lendo o dividendo
    syscall
    move $t0, $v0

    li $v0, 5       #lendo o divisor
    syscall
    move $t1, $v0

    addi $t5, $zero, 32     #utilizando a variavel para guardar o numero 32

    addi $t2, $zero, 1      #inicializando o contador em 1
    add $t3, $t0, $zero     #colocando o dividendo na parte menos significativa do resto
    sll	$t3, $t3, 1	        # $t3 = $31 << 1

    repeticao:
        sub $t3, $t3, $t1           #subtraindo o resto pelo divisor 
        slt $t4, $t3, $zero 
        bne $t4, $zero, men_zero    #vendo se é menor ou maior que 0, caso seja menor vai para
        j mai_zero                  #men_zero, caso seja maior vai para mai_zero

        mai_zero:
            sll $t3, $t3, 1         #Caso seja maior que 0, desloco um bit para a esquerda e
            addi $t3, $t3, 1        #adiciono 1 para ficar com o valor 1 no último bit
            j contador              
    
        men_zero:
            add $t3, $t3, $t1       #Caso contrário, adiciono novamente o valor que estava no
            sll $t3, $t3, 1         #resto e continuo o programa
            j contador

        contador:
            sub $t4, $t2, $t5           #diminuo o contador de 32 e vejo se acabou a repetição
            addi $t2, $t2, 1            #Adiciono 1 no contador
            slt $t4, $t4, $zero         #caso não tenha acabado, mando refazer o processo
            bne $t4, $zero, repeticao
    
    srl $t3, $t3, 1     #mando fazer um deslocamento à direita
    li $v0, 4           #tento printar o valor contido no resto
    move $a0, $t3
    syscall
    
    li $v0, 4           #printo o contra barra n
    la $a0, cbn
    syscall

    li $v0, 10          #finalizo o programa
    syscall
